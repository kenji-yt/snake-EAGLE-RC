## Check minimum Snakemake version

from snakemake.utils import min_version

min_version("5.20.1")

## Import required libraries
import os
import glob
import re 

## Configuration check

if len(config) == 0:
    
    sys.exit(
        f"Please specify the path to the input directory with --config INPUT='path/to/input'."
    )


## Parse Input directory

INPUT_DIR = os.path.normpath(config["INPUT"])
DATA_TYPE = os.path.basename(INPUT_DIR) # Assumes user named input directory after data type (DNA, RNA, WGBS) unless a config file is provided. 
if DATA_TYPE=="DNA":
    ALIGNER="bwa"
elif DATA_TYPE=="RNA":
    ALIGNER="star"
elif DATA_TYPE=="WGBS":
    ALIGNER="bismark"
else:
    sys.exit(
        f"ERROR: Unknown data type. Name the input directory after the data type: 'DNA', 'RNA' or 'WGBS'."
        )


SAMPLES = [ sample for sample in os.listdir(f"{INPUT_DIR}/polyploids") if sample != "control_genome" ] # Control genome used in methylation data (!?)
PROGENITORS = os.listdir(f"{INPUT_DIR}/progenitors") 



# If a config file is desired/necessary we can add if statement to see if it exists in the input directory. 
# Then verify if input dir format matches config specifications. 

# get file count and list within sample directories

sample_files = {}
for sample in SAMPLES:

    sample_dir = os.path.join(f"{INPUT_DIR}/polyploids", sample)
    
    files  = os.listdir(sample_dir)

    sample_files[sample] = files 

# get all read files
accepted_read_patterns = [
        f"{INPUT_DIR}/polyploids/**/*.fastq",
        f"{INPUT_DIR}/polyploids/**/*.fasta",
        f"{INPUT_DIR}/polyploids/**/*.fna",
        f"{INPUT_DIR}/polyploids/**/*.fq",
        f"{INPUT_DIR}/polyploids/**/*.fa",
        f"{INPUT_DIR}/polyploids/**/*.fastq.gz",
        f"{INPUT_DIR}/polyploids/**/*.fasta.gz",
        f"{INPUT_DIR}/polyploids/**/*.fna.gz",
        f"{INPUT_DIR}/polyploids/**/*.fq.gz",
        f"{INPUT_DIR}/polyploids/**/*.fa.gz",
    ]
all_read_files = [] 
for pattern in accepted_read_patterns:
        all_read_files.extend(glob.glob(pattern, recursive=True))


### Make wildcard constraints ###
import re
sample_regex = "|".join(re.escape(sample) for sample in SAMPLES)
progenitor_regex = "|".join(re.escape(progenitor) for progenitor in PROGENITORS)

wildcard_constraints: # limit the value of these wildcards to directory names 
    sample = sample_regex,
    progenitor = progenitor_regex


### Rules ###

include: "rules/alignment.smk"
include: "rules/input_functions.smk"
include: "rules/quality_check.smk"
include: "rules/read_sorting.smk"

rule all:
    input:
        "results/snake-EAGLE-RC-reproducibility_report.txt"

rule make_reproducibility_report:
    input:
        input_dir=f"{INPUT_DIR}",
        multi_qc="results/MultiQC/multiqc_report.html"
    output:
        "results/snake-EAGLE-RC-reproducibility_report.txt"
    threads: workflow.cores
    shell:
        "bash {workflow.basedir}/scripts/make_reproducibility_report.sh {input.input_dir} {threads}"
